[02 명시적으로 this를 바인딩하는 방법]
- 사용자가 임의로 this에 별도의 대상을 바인딩하는 방법들. 
- 즉, 전역공간, 메서드 내부, 생성자 함수 내부 등 
  특정 상황에 따라 자동으로 this에 특정 값이 바인딩된다는 규칙을 깨는 방법.
 
----------------------------------------------------
1) call 메서드: 첫번째 인자로 객체를 받아서 this로 바인딩시키면서,
                메서드의 호출 주체인 함수를 즉시 실행하도록 하는 명령.
- 나머지 인자들은 실행할 함수의 매개변수로 보냄.          

함수(a, b, c); // this는 전역객체를 참조.
함수.call({객체}, a, b, c); // {객체}는 함수의 this로 바인딩됨.

객체.메서드(a, b, c); // this는 객체를 참조.
객체.메서드.call({객체}, a, b, c); // {객체}는 메서드의 this로 바인딩됨.
--------------------------
2) apply 메서드: 첫번째 인자로 객체를 받아서 this로 바인딩시키면서 
                메서드의 호출 주체인 함수를 즉시 실행하도록 하는 명령
- 두번째 인자로 배열을 받고, 배열의 요소들을 실행할 함수의 매개변수로 보냄.    
- 함수의 인자들을 하나의 배열로 묶는다는 점에서만 call과 차이 존재.
- call과 apply는 동일한 기능. 다른 형식.

함수.apply({this 객체}, [a, b, c]); 
객체.메서드.apply({this 객체}, [a, b, c]);
--------------------------
3) call & apply 메서드의 활용 방법 
- 유사배열객체에 배열 메서드 적용하기 위해 call/apply 활용 가능.
  [ES6] 가급적 Array.from 메서드 사용할 것 call/apply 불필요.
- 생성자 내부에서 다른 생성자 호출하기 위해 지금도 call/apply 활용
- 여러 개의 인수를 받는 메서드에 하나의 배열로 인수들 전달하기 위해 apply 활용 가능. 
  [ES6] 펼치기 연산자 spreader operator 사용하면 apply 불필요.

:: 전부 ES5 이하의 환경에서는 지금도 실무에서 광범위하게 활용되는 방식들
--------------------------
4) bind 메서드: 인자로 넘겨받은 this와 인수들을 토대로 새로운 함수를 return하는 명령.
- call 메서드와 기본 형식 동일. 즉시 실행이 아니라 return한다는 점에서 차이.
- return받고 새로운 변수에 할당하고 새로운 함수로서 활용.

함수1 = (a, b, c, d) => { ~~ }
함수2 = 함수1.bind({객체}); // this값만 지정.
함수2(a1, b1, c1, d1); // 실행할 때는 인자 4개 그대로 받음.
console.log(함수2.name); // 출력: bound 함수1

함수3 = 함수1.bind({객체}, a, b); // this 값 + 인자1, 인자2 지정.
함수3(c1, d1); // 실행할 때는 인자3, 인자4만 지정 가능.
console.log(함수3.name); // 출력: bound 함수1

cf) 내부함수나 콜백 함수에 '상위 컨텍스트의 this'를 전달하기 위해서도 call/apply/bind 사용 가능.
--------------------------
5) 화살표 함수의 예외사항: 가장 효과적인 this 우회 방법.
- 화살표 함수 내부에는 this 값이 아예 없음. 애초에 실행 컨텍스트를 생성할 때 this 바인딩 과정이 제외됨.
- 접근하고자 하면 자동으로 스코프체인상 가장 가까운 this에 접근하게 됨

--------------------------
6) 별도의 인자로 this를 받는 경우(콜백 함수 내에서의 this)







