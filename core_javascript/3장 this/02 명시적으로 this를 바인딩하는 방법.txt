[02 명시적으로 this를 바인딩하는 방법]
- 사용자가 임의로 this에 별도의 대상을 바인딩하는 방법들. 
- 즉, 전역공간, 메서드 내부, 생성자 함수 내부 등 
  특정 상황에 따라 자동으로 this에 특정 값이 바인딩된다는 규칙을 깨는 방법.
 
----------------------------------------------------
1) call 메서드: 첫번째 인자로 객체를 받아서 this로 바인딩시키면서,
                메서드의 호출 주체인 함수를 즉시 실행하도록 하는 명령.
- 나머지 인자들은 실행할 함수의 매개변수로 보냄.          

함수(a, b, c); // this는 전역객체를 참조.
함수.call({객체}, a, b, c); // {객체}는 함수의 this로 바인딩됨.

객체.메서드(a, b, c); // this는 객체를 참조.
객체.메서드.call({객체}, a, b, c); // {객체}는 메서드의 this로 바인딩됨.
--------------------------
2) apply 메서드: 첫번째 인자로 객체를 받아서 this로 바인딩시키면서 
                메서드의 호출 주체인 함수를 즉시 실행하도록 하는 명령
- 두번째 인자로 배열을 받고, 배열의 요소들을 실행할 함수의 매개변수로 보냄.    
- 함수의 인자들을 하나의 배열로 묶는다는 점에서만 call과 차이 존재.
- call과 apply는 동일한 기능. 다른 형식.

함수.apply({this 객체}, [a, b, c]); 
객체.메서드.apply({this 객체}, [a, b, c]);
--------------------------
3) call & apply 메서드의 활용 방법
- 유사배열객체에 배열 메서드 적용하기 위해 call/apply 활용 가능.
  [ES6] 가급적 Array.from 메서드 사용할 것 call/apply 불필요.
- 생성자 내부에서 다른 생성자 호출하기 위해 지금도 call/apply 활용
- 여러 개의 인수를 받는 메서드에 하나의 배열로 인수들 전달하기 위해 apply 활용 가능. 
  [ES6] 펼치기 연산자 spreader operator 사용하면 apply 불필요.

:: 전부 ES5 이하의 환경에서는 지금도 실무에서 광범위하게 활용되는 방식들
--------------------------
4) bind 메서드

5) 화살표 함수의 예외사항

6) 별도의 인자로 this를 받는 경우(콜백 함수 내에서의 this)







