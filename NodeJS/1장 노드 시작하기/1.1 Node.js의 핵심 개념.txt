[핵심 개념 이해하기] 
<서버>
: 클라이언트의 요청에 대해 응답을 하는 주체. 
: 네트워크를 통해 클라이언트에 정보나 서비스를 제공하는 컴퓨터 혹은 프로그램 
- 웹사이트 주소에 해당하는 컴퓨터(데이터베이스, html파일 등을 응답함)
- 구글/애플의 서버 (모바일 앱 설치 파일을 응답함)
- 특정 사용자를 차단하는 등 서버가 응답하지 않을 수도 있음

클라이언트: 서버에 요청을 보내는 주체. 
- 브라우저, 데스크톱 프로그램
- 플레이 스토어, 앱스토어 
- 서버도 다른 서버에 요청을 보내는 경우 클라이언트 역할을 하게 됨.

Node.js는 JS 프로그램이 서버로서 기능하기 위한 도구를 제공 => 서버 역할 수행 가능.

---------------------------------------
---------------------------------------
<자바스크립트 런타임>
"Node.js는 Chrome V8 JavaScript 엔진으로 빌드된 JavaScript 런타임입니다." (https://nodejs.org/ko/)

런타임: 특정 언어로 만든 프로그램들을 실행할 수 있는 환경.
---------
과거 웹 브라우저만 자바스크립트 런타임을 내장하고 있음
(즉, 오직 웹브라우저에서만 JS 프로그램을 실행할 수 있었음)

지금은 Node.js 덕분에 다양한 자바스크립트 프로그램을 컴퓨터에서 실행 가능
즉, Node.js는 일종의 자바스크립트 실행 도구
물론 서버 애플리케이션을 실행하는 데 제일 많이 사용됨. 
---------
[Node.js Core Library]
 [Node.js Bindings]
   [V8]   [libuv]
                    
V8 엔진: 오픝소스, 자바스크립트 엔진. 구글이 크롬을 개발하는 데 사용.
libuv 라이브러리: 비동기 I/O. Node.js의 특성인 이벤트 기반, 논블로킹 I/O 모델을 구현함.
- JS 코드들을 Node.js가 알아서 V8엔진과 libuv 라이브러리에 연결해줌.
- 둘 다 C와 C++로 구현됨.

---------------------------------------
---------------------------------------
<이벤트 기반(event-driven)>
: 클릭, 네트워크 요청 등 이벤트가 발생할 때, 미리 지정해둔 작업을 수행하는 방식

[이벤트 기반 시스템]
1) 이벤트 리스너(event listener)에 콜백함수(callback finction)을 등록
  = 특정 이벤트가 발생할 때 무엇을 할지 미리 등록.
2) 시스템에서 이벤트 발생
3) 이벤트리스너에 등록된 콜백함수 호출
- 발생한 이벤트가 없거나 전부 다 처리했으면, 다음 이벤트 발생할 때까지 대기
-------------------------
function run(){
  console.log("3초 후 실행");
}
console.log("시작"); // 시작
setTimeout(run, 3000);  
console.log("끝"); // 끝 
 // 3초 후 실행 

<실행결과> 
1) setTimeout 호출시, 콜스택에 setTimeout 컨텍스트가 쌓이고, setTimeout를 실행. 
2) [콜스택]에서 [백그라운드]로 콜백함수 run을 타이머와 함께 보냄. 
- 콜스택에서 setTimeout 컨텍스트 제거되고, 전역 컨텍스트의 다른 코드들 실행. 
3) [백그라운드]에서 3초가 지나면, 콜백함수 run을 [태스크 큐]로 보냄. 
= 백그라운드에 맡겨진 작업(타이머 run 3초): 3초 대기 후 콜백 run을 [태스크 큐]로 보내는 것. 
4) [콜스택]이 완전히 비어있다면 [이벤트 루프]가 [태스크 큐]의 콜백 run을 [콜스택]으로 전달. 
- [콜스택]에서는 [태스크 큐]로부터 받은 run을 실행.
5) 이벤트루프틑 태스크큐에 콜백함수가 들어올 때까지 계속 대기

cf) setTimeout의 콜백함수 run은 정확히 3초 후에 실행되지 않을 수 있음.
- 3초가 지났어도 [콜스택]에 전역 컨텍스트 등 다른 함수들이 여전히 존재하면 콜백 run은 계속 태스크 큐에 대기.  
-------------------------
이벤트 루프(event loop)
- 이벤트 발생시 호출할 콜백함수들을 관리
- 호출된 콜백함수들의 실행 순서를 판단하고 결정
- <콜스택이 비어있으면 태스크 큐에 있는 콜백함수를 하나씩 콜스택으로 보내서 실행>
: Node.js가 종료될 때까지 이벤트 처리를 위한 작업을 계속 반복

콜스택(call stack) : 컨텍스트들이 쌓이는 공간 (컨텍스트: 함수가 호출되었을 때 생성되는 환경)
: 순차적으로 개별 함수들이 호출되면서 각각의 컨텍스트들이 콜스택에 쌓이고, 
  맨 위의 컨텍스트부터 순차적으로 실행되면서 지워짐.
: 전역 컨텍스트(global context)는 최초로 쌓이고 실행, 맨 마지막에 사라지면서 코드 전체 종료.
 
백그라운드(background)
: 이벤트리스너들과 타이머(setTimeout 등)가 대기하는 곳
: 이벤트가 발생하면 이벤트리스너나 타이머의 '콜백함수'를 [태스크큐]로 보냄.
: 여러 작업 동시에 실행 가능.
- JS가 아닌 다른 언어로 작성된 프로그램.

태스크 큐(task queue) (= 콜백 큐)
: 이벤트 발생시 [백그라운드]로부터 '콜백함수'를 전달받음.
: 기본적으로 콜백함수들은 완료된 순서대로 줄을 서 있게 됨. 
  다만, 순서가 바뀌는 경우도 있음.

---------------------------------------
---------------------------------------
<논 블로킹 I/O>
기본적으로 자바스크립트 코드는 여러 작업을 동시에 실행할 수 없지만,
Node.js에서는 논블로킹 방식으로 코딩할 경우 I/O 작업들을 동시에 처리 가능.
- 즉, Node.js는 I/O 작업을 [백그라운드]로 넘겨 동시에 처리 가능.
- 동시에 처리 가능한 작업들을 최대한 함께 묶어서 실행하도록 하면 시간 절약됨.
=> 가급적 논블로킹 방식으로 코딩하는 습관을 들여야 함. (성능 향상)
-------------------------
I/O 작업: 입력(Input)/출력(Output).
- 파일 시스템 접근 작업(파일 읽기, 파일 쓰기, 폴더 생성 등)
- 네트워크를 통한 요청 작업 등
cf) 해당 작업들은 자바스크립트상에서 돌아가지 않음.

블로킹: 이전 작업이 완전히 끝난 이후에 다음 작업을 수행. (동기와 유사)
논블로킹: 이전 작업이 완료될 때까지 대기하지 않고 곧바로 다음 작업을 수행 (비동기와 유사)
- 동시처리가 가능한 작업들을 함께 묶어서 백그라운드로 넘기면
  (=논블로킹 처리)하면 동시성을 얻게 됨. 같은 양의 작업을 더 빨리 처리가능해짐.

-------------------------
ex) 작업 실행 순서에 따른 작업 시간 단축 (=성능 향상)
[a] b [c] d [e] : 5초 소요
b [a c e] d : 동시에 처리 가능한 작업들 a, c, e를 함께 묶은 경우. 3초 소요.

-------------------------
논블로킹 코딩 기법 원리: setTimeout(콜백, 0) 
function longTask() {
  console.log("A Really Long Task");
}
console.log("Start");
setTimeout(longTask, 0);
console.log("The Next Task");
// "Start"
// "The Next Task"
// "A Really Long Task"

<콜백함수 longtask의 실행순서가 바뀌는 원인 (복습)>
콜스택은 setTimeout의 콜백함수 longtask를 백그라운드로 보내고,
백그라운드는 0초 후에 longTask를 태스크큐로 보낸 후,
이벤트루프는 콜스택이 비게 되었을 때 태스크큐의 longTask를 콜스택으로 보냄.

cf) 전체 처리 시간이 변하지 않더라도 실행순서를 바꿈으로써 간단한 작업들을 
    우선적으로 처리할 수 있음. 복잡한 작업 때문에 대기하는 상황을 막을 수 있음. 

---------------------------------------
---------------------------------------
<싱글 스레드 모델>
Node.js는 기본적으로 싱글스레드+논블로킹 모델(자바스크립트 자체의 특성)

싱글 스레드: 스레드가 하나뿐. 자바스크립트 코드가 동시에 실행될 수 없는 이유

하나의 운영체제에 복수의 프로세스들 / 하나의 프로세스에 복수의 스레드들

프로세스: 운영체제에서 할당하는 작업의 단위. 
- Node.js, 웹브라우저 등의 프로그램들은 개별적인 프로세스
- 하나의 운영체제 내에 다양한 프로세스들 함께 존재
- 각각의 프로세스 간에는 메모리 등의 자원을 공유하지 않음.

스레드: 프로세스 내에서 실행되는 흐름의 단위. 
- 하나의 프로세스는 스레드를 여러 개 생성하여 여러 작업을 동시에 처리 가능.
- 스레드들은 부모 프로세스의 자원을 공유.
- 같은 주소의 메모리에 접근 가능하기 때문에 스레드들 간에는 데이터 공유 가능
- 일종의 작업을 처리하는 '일손'

--------
Node.js는 엄밀히 말했을 때 싱글 스레드로 동작하지 않음.
 Node.js를 실행시, 하나의 프로세스 생성 => 프로세스에서 복수의 스레드들을 생성 
 이 중 개발자가 직접적으로 제어 가능한 스레드는 기본적으로 오직 한 개.
=> 하나의 일손 => 요청이 많이 들어오게 되면 한번에 하나씩 요청을 처리하게 됨
=> 블로킹이 발생할 것 같은 경우, 논블로킹 방법으로 코딩하여 대기 시간을 줄여야 함.

cf) Node.js가 싱글스레드로 동작하지 않는 두 가지 경우
스레드풀(Thread Pool): 암호화, 파일 입출력, 압축 등 특정 동작을 수행할 때 Node.js가 스스로 멀티스레드를 사용함.
워커 스레드(Worker Thread): Node.js에서 멀티스레드를 사용하기 위해 도입됨. 버전12에서 안정화됨. CPU 작업이 많은 경우 사용하면 됨.

--------
하지만 싱글스레드보다 멀티스레드가 언제나 좋은 것은 아님.
멀티스레드+블로킹의 경우 문제 많이 발생.
멀티스레드+논블로킹은 구현하기 어렵고, I/O 요청에는 멀티 프로세싱이 더 효율적.
==> 때문에 Node.js는 멀티 프로세싱을 많이 사용함.
-----
멀티스레딩: 하나의 프로세스 안에서 여러 개의 스레드 사용
- CPU 작업이 많을 때 사용.
- 프로그래밍이 어려움.

멀티프로세싱: 여러개의 프로세스 사용
- I/O 요청이 많을 때 사용.
- 프로그래밍이 비교적 쉬움.
